{
    "contents" : "# TODO: Add comment\n# \n# Author: SSP24298\n###############################################################################\n\n\nmarch.ci.h.A <- function(n,ni){\n  (ni-1/8)/(n+1/8)\n}\n\nmarch.ci.h.B <- function(n,ni){\n  (ni+7/8)/(n+1/8)\n}\n\nmarch.ci.h.C <- function(alpha,K,n){\n  qchisq(1-alpha/K,df=1)/(4*n)\n}\n\n# Get the d^2*n value as defined in Thompson 1987 p43 paper \n# (\"Sample Size for Estimating Multinomial Proportions\").\n# The value is available for some value of alpha (as defined in the vector a).\n# If the alpha value is not defined, the default value (for alpha=0.05) is\n# returned.\n#\n# Parameters : \n#   alpha : the significance level (alpha)\n#\n# Returns :\n#  the d^2*n associated with the alpha value, if defined, or the one\n#\tassociated with alpha=0.05.\n#\nmarch.ci.h.d2n <- function(alpha){\n  a <- c( 0.5,0.4,0.3,0.2,0.1,0.05,0.025,0.02,0.01,0.005,0.001,0.0005,0.0001 )\n  d2n <- c( 0.44129,0.50729,0.60123,0.74739,1.00635,1.27359,1.55963,1.65872,1.96986,2.28514,3.02892,3.33530,4.11209)\n  \n  id <- which(a==alpha)\n  \n  if( !length(id) ){\n    warning(\"alpha value has not been found, using 0.05 instead.\",call.=FALSE)\n    id <- which(a==0.05)\n  }\n  \n  d2n[id]\n}\n\n# the expectation of Z_t(g)\nmarch.mtd.h.z <- function(mtd,y,t,g){\n  s <- 0\n  for( k in 1:mtd@order ){\n    s <- s+mtd@phi[k]*mtd@Q[1,y@y[t-k],y@y[t]]\n  }\n  mtd@phi[g]*mtd@Q[1,y@y[t-g],y@y[t]]/s\n}\n\n\n# the weight coefficient for the g-th lag \nmarch.mtd.h.l <- function(mtd,y,g){\n  s <- 0\n  for( i in 1:y@N ){\n    ys <- march.dataset.h.extractSequence(y,i)\n    for( t in march.h.seq(mtd@order+1,ys@N)){\n      s <- s+ march.mtd.h.z(mtd,ys,t,g)\n    }\n  }\n  s\n}\n\n# Matrix containing the estimations of the number of data used to compute each element of Q\nmarch.mtd.h.n <- function(mtd,y){\n  nki_0 <- array(0,c(mtd@y@K,mtd@y@K))\n  for( k in 1:mtd@y@K ){\n    for( i0 in 1:mtd@y@K){\n      s <- 0\n      for( i in 1:y@N ){\n        ys <- march.dataset.h.extractSequence(y,i)\n        for( t in march.h.seq(mtd@order+1,ys@N) ){\n          if( ys@y[t]==i0 ){\n            for( g in 1:mtd@order ){\n              if( ys@y[t-g]==k)\n                s <- s+march.mtd.h.z(mtd,ys,t,g)\n            }\n          }      \n        }\n      }\n      nki_0[k,i0] <- s\n    }\n  }\n  nki_0\n}\n\n\nmarch.indep.bailey <- function( indep, alpha ){\n  n <- sum(indep@dsL)\n  \n  p <- array(NA,c(2,indep@K))\n  colnames(p) <- indep@y@dictionary\n  rownames(p) <- c(\"p-\",\"p+\")\n  for( i in 1:indep@K){\n    ni <- indep@indC[i]\n    A <- march.ci.h.A(n,ni)\n    B <- march.ci.h.B(n,ni)\t\n    C <- march.ci.h.C(alpha,indep@K,n)\n    \n    p[\"p-\",i] = (sqrt(A)-sqrt(C*(C+1-A)))^2/(C+1)^2\n    p[\"p+\",i] = (sqrt(B)+sqrt(C*(C+1-B)))^2/(C+1)^2\n  }\n  \n  \n  p\n}\n\n#' Compute Confidence Interval for MC model\n#'@export\nmarch.mc.bailey <- function( mc, alpha ){\n  n <- mc@dsL\n  pm <- array(NA,dim(mc@RT))\n  pp <- array(NA,dim(mc@RT))\n  for( i in 1:(mc@K^mc@Order)){\n    for( j in 1:mc@K){\n      ni <- mc@RT[i,j]\n      if( ni>0 ){\n        A <- march.ci.h.A(n,ni)\n        B <- march.ci.h.B(n,ni)  \n        C <- march.ci.h.C(alpha,mc@K,n)\n        \n        pm[i,j] = (sqrt(A)-sqrt(C*(C+1-A)))^2/(C+1)^2\n        pp[i,j] = (sqrt(B)+sqrt(C*(C+1-B)))^2/(C+1)^2\n      }\n    }\n  }\n  list(pm=pm,pp=pp)\n}\n\n#' Bailey CI function (temporary version for mtd)\n#' @export\nmarch.mtd.bailey <- function( mtd, alpha ){\n  n <- mtd@dsL\n  pm <- array(NA,dim(mtd@Q))\n  pp <- array(NA,dim(mtd@Q))\n  \n  \n  if( dim(mtd@Q)[1]==1 ){\n    nki_0 <- march.mtd.h.n(mtd,mtd@y)\n    # mtd case\n    for( i in 1:dim(mtd@Q)[2]){\n      for( j in 1:dim(mtd@Q)[3]){\n        nij <- nki_0[i,j]\n        if( nij>0 ){\n          A <- march.ci.h.A(n,nij)\n          B <- march.ci.h.B(n,nij)  \n          C <- march.ci.h.C(alpha,mtd@y@K,n)\n          \n          pm[1,i,j] = (sqrt(A)-sqrt(C*(C+1-A)))^2/(C+1)^2\n          pp[1,i,j] = (sqrt(B)+sqrt(C*(C+1-B)))^2/(C+1)^2\n        }\n      } \n    }\n  }\n  else{\n    # mtdg case\n  }\n  print(pm[1,,])\n  print(pp[1,,])\n}\n\nalphat <- function(d,s){\n  a <- array(0,c(s@N,2))\n  \n  a[1,] <- d@RB[,1,s@y[1]]*d@Pi[1,1,]\n  for( t in 2:s@N ){\n    for( g in 1:d@M ){\n      for( i in 1:d@M ){\n        a[t,g] <- a[t,g]+a[t-1,i]*d@A[i,g]*d@RB[g,1,s@y[t]]\n      }\n    }\n  }\n  a\n}\n\nbetat <- function(d,s){\n  b <- array(0,c(s@N,2))\n  \n  b[s@N,] <- c(1,1)\n  for( t in (s@N-1):1 ){\n    for( g in 1:d@M ){\n      for( i in 1:d@M ){\n        b[t,i] <- b[t,i]+d@A[i,g]*d@RB[g, 1 ,s@y[t+1]]*b[t+1,g]\n      }\n    }\n  }\n  b\n}\n\nmarch.dcmm.exp_z <- function(d,alpha,beta,t,g,n){\n  L <- sum(alpha[n,])\n  \n  alpha[t,g]*beta[t,g]/L\n}\n\n#\nmarch.dcmm.test <- function(d){\n  PoA <-  array(0,c(d@M^d@orderHC))\n  PoCt <- array(0,c(d@M^d@orderHC))\n  for( i in 1:d@y@N ){\n    # number of point for A\n    s <- march.dataset.h.extractSequence(d@y,i)\n    \n    a <- march.dcmm.forward(d,s)\n    b <- march.dcmm.backward(d,s)\n    epsilon <- march.dcmm.epsilon(d,s,a$alpha,b$beta,a$l,b$l,a$LL)\n    gamma <- march.dcmm.gamma(d,s,a$alpha,b$beta,a$l,b$l,a$LL,epsilon)\n    \n    PoA <- PoA+colSums(gamma[d@orderHC:(d@y@T[i]),])\n    \n    if( d@M>2 ){\n      PoCt <- PoCt+colSums(gamma[1:(d@M-1),])+colSums(gamma[d@M:d@y@T[i],])  \n    }\n    else{\n      PoCt <- PoCt+gamma[1,]+colSums(gamma[d@M:d@y@T[i],])  \n    }\n  }\n  \n  PoC <- array(0,c(1,d@M))\n  for( i in 0:(d@M-1) ){\n    PoC[i+1] <- sum(PoCt[(i*d@orderHC+1):((i+1)*d@orderHC)])\n  } \n  list(PoA,PoC)\n}",
    "created" : 1400311328282.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1824849014",
    "id" : "C70C6C0B",
    "lastKnownWriteTime" : 1400311373,
    "path" : "~/Desktop/Bur/mc-RC3/mc/R/march.ci.R",
    "project_path" : "R/march.ci.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}