{
    "contents" : "#\n# Author: Ogier Maitre\n###############################################################################\n\nmarch.dcmm.constructEmptyDcmm <- function(M,y,orderVC,orderHC){\n  RB <- array(1/y@K,c(M,y@K^orderVC,y@K)) # emit\n  Pi <- array(1/M,c(orderHC,M^(orderHC-1),M))\n  \n  RA <- array(1/M,c(M^orderHC,M))\n  A <- march.dcmm.h.expandRAInternal(RA,M,orderHC) \n  \n  new(\"march.Dcmm\",Pi=Pi,A=A,M=M,orderVC=orderVC,orderHC=orderHC,RB=RB,y=y)\n}\n\n\nmarch.dcmm.h.encodeOutput <- function(s,t,d){\n  \n  if( d@orderVC>0 ){\n    code <- array(0,c(d@orderVC-1))\n    i <- march.h.seq(0,d@orderVC-1)\n    code = d@y@K^(i)*(s@y[i+(t-d@orderVC)]-1)\n    sum(code)+1\n  }\n  else{\n    1\n  }\n}\n\nmarch.dcmm.h.scaleAlpha <- function(j,alphat){\n  mA <- sum(alphat[1:j])/j\n  if( mA==0 ){\n    alphat[1:j] <- matrix(1,ncol=1,nrow=j)*(1/j)\n    l <- 1\n  }\n  else{\n    alphat[1:j] <- alphat[1:j]/mA\n    l <- mA\n  }\n  list(scaled=alphat,scale=l)\n}\n\n\nmarch.dcmm.h.expandRA <- function(d,RA){\n  march.dcmm.h.expandRAInternal(RA,d@M,d@orderHC)\n}\n\nmarch.dcmm.h.expandRAInternal <- function(RA,M,orderHC){\n  A <- array(0,c(M^orderHC,M^orderHC))\n  \n  for( r2 in 1:M ){\n    for( r1 in march.h.seq(1,M^(orderHC-1)) ){\n      for( c in 1:M ){\n        A[(r1-1)*M+r2,r1+(c-1)*M^(orderHC-1)] <- RA[(r1-1)*M+r2,c]\n      }\n    }\n  }\n  \n  A\n}\n\nmarch.dcmm.h.compactA <- function(d){\n  RA <- array(0,c(d@M^d@orderHC,d@M))\n  \n  for( r2 in 1:d@M ){\n    for( r1 in 1:d@M^(d@orderHC-1) ){\n      for( c in 1:d@M ){\n        RA[(r1-1)*d@M+r2,c] <- d@A[(r1-1)*d@M+r2,r1+(c-1)*d@M^(d@orderHC-1)]\n      }\n    }\n  }\n  \n  RA\n}\n\n\n#' Viterbi algorithm for dcmm model.\n#' \n#' @param d the \\code{\\link{march.Dcmm}} on which computes the most likely sequences of hidden states.\n#' @param y the \\code{\\link{march.Dataset}} to consider.\n#' \n#' @return A list of vector containing the most likely sequences of hidden states, considering the given model for each sequence of the given dataset.\n#'\n#'@export\nmarch.dcmm.viterbi <- function(d,y){\n  \n  l <- list()\n  \n  for( n in 1:y@N ){  \n    s <- march.dataset.h.extractSequence(y,n)\n    delta <- matrix(0,nrow=s@N,ncol=d@M^d@orderHC)\n    \n    # intial step t=orderVC+1\n    t = d@orderVC+1\n    for( j0 in 1:d@M ){\n      delta[t,j0] <- d@Pi[1,1,j0]*d@RB[j0,march.dcmm.h.encodeOutput(s,t,d),s@y[t]]\n    }\n    \n    delta[t,] <- march.dcmm.h.scaleAlpha(d@M,delta[t,])$scaled\n    \n    if( d@orderHC>1 ){\n      # initial step to<=orderVC+orderHC\n      for( t in march.h.seq(d@orderVC+2,d@orderVC+d@orderHC)){\n        rowC <- march.dcmm.h.encodeOutput(s,t,d)\n        for( j in 1:(d@M^(t-d@orderVC)) ){\n          j0 = floor((j-1)/(d@M^(t-d@orderVC-1)))+1;\n          delta[t,j] <- max(delta[t-1,]*d@Pi[t-d@orderVC,,j0])*d@RB[j0,rowC,s@y[t]]\n        }\n        delta[t,] <- march.dcmm.h.scaleAlpha(d@M^(t-d@orderVC),delta[t,])$scaled\n      }\n    }\n    \n    # Induction to t=length(y)\n    for( t in (d@orderVC+d@orderHC+1):s@N){ #\n      rowC <- march.dcmm.h.encodeOutput(s,t,d)\n      for( j in 1:(d@M^d@orderHC)){\n        j0 = floor((j-1)/(d@M^(d@orderHC-1)))+1;\n        delta[t,j] <- max(delta[t-1,]*d@A[,j])*d@RB[j0, rowC,s@y[t]]\t\t\t\n      }\n      delta[t,] <- march.dcmm.h.scaleAlpha(d@M^d@orderHC,delta[t,])$scaled\n    }\n    \n    \n    X <- vector(mode=\"integer\",s@N)\n    e_t = which.max(delta[t,])\n    x_t = floor((e_t-1)/(d@M^(d@orderHC-1)))+1\n    \n    X[s@N] <- x_t\n    \n    # find the best sequence of hidden step\n    for( t in seq(s@N-1,d@orderVC+d@orderHC) ){\n      e_t <- which.max(delta[t,]*d@A[,e_t])\n      x_t <- floor((e_t-1)/(d@M^(d@orderHC-1)))+1\n      X[t] <- x_t\n    }\n    \n    for( t in seq(d@orderHC+d@orderVC-1,d@orderVC+1)){\n      e_t <- which.max(delta[t,]*d@Pi[t-d@orderVC+1,x_t,])\n      X[t] <- floor((e_t-1)/(d@M^(d@orderHC-1)))+1\t\n    }\n    l[[n]] <- X\n  }\n  l\n}\n\n#\n# parameters :\n#\td : a Dcmm object (see Dcmm class)\n#\ty : a vector containing variable sequence.\n#\n# return : \n#\nmarch.dcmm.forward <- function(d,s){\n  alpha <- matrix(0,nrow=s@N,ncol=d@M^d@orderHC)\n  l <- vector(\"numeric\",s@N)\n  \n  # intial step t=orderVC+1\n  t <- d@orderVC+1;\t\n  alpha[t,1:d@M] <- d@RB[,march.dcmm.h.encodeOutput(s,t,d),s@y[t]]*d@Pi[1,1,]\n  \n  scaled <- march.dcmm.h.scaleAlpha(d@M,alpha[t,])\n  alpha[t,]<- scaled$scaled\n  l[t] <- log(scaled$scale)\n  \n  if( d@orderHC>1 ){\n    # initial step to<=orderVC+orderHC\n    for( t in march.h.seq((d@orderVC+2),(d@orderVC+d@orderHC)) ){\n      rowC <- march.dcmm.h.encodeOutput(s,t,d)\n      for( i in march.h.seq(1,d@M^(t-d@orderVC-1)) ){\n        j<-1:d@M\n        j0 <- d@M^(t-d@orderVC-1)*(j-1)+i\n        alpha[t,j0] <- d@RB[j,rowC,s@y[t]]*d@Pi[t-d@orderVC,i,j]*alpha[t-1,i]\n      }\n      scaled <- march.dcmm.h.scaleAlpha(d@M^(t-d@orderVC),alpha[t,])\n      alpha[t,] <- scaled$scaled\n      l[t] <- log(scaled$scale)\n    }\n  }\n  \n  # Induction to t=length(y)\n  for( t in march.h.seq(d@orderVC+d@orderHC+1,s@N) ){\n    rowC <- march.dcmm.h.encodeOutput(s,t,d)\n    for( j in 1:(d@M^d@orderHC)){\n      j0 = floor((j-1)/(d@M^(d@orderHC-1)))+1;\n      alpha[t,j] <- t(alpha[t-1,])%*%d@A[,j]*d@RB[j0, rowC,s@y[t]]\n    }\n    scaled <- march.dcmm.h.scaleAlpha(d@M^d@orderHC,alpha[t,])\n    alpha[t,]<- scaled$scaled\n    l[t] <- log(scaled$scale)\n  }\n  \n  LL <- log(sum(matrix(1,ncol=1,nrow=d@M^d@orderHC)*alpha[s@N,]))+sum(l*matrix(1,nrow=length(s),ncol=1))\n  list(alpha=alpha,l=l,LL=LL)\n}\n\n\n\nmarch.dcmm.backward <- function(d,s){\n  beta <- matrix(0,nrow=s@N,ncol=d@M^d@orderHC)\n  l <- vector(\"numeric\",s@N)\n  \n  beta[s@N,] <- matrix(1,ncol=d@M^d@orderHC,nrow=1)\n  \n  \n  for( t in march.h.seq(s@N-1,d@orderVC+d@orderHC,-1)){\n    rowC <- march.dcmm.h.encodeOutput(s,t+1,d)\n    for( i in 1:(d@M^(d@orderHC))){\n      for( j in 1:d@M ){\n        col <- d@M^(d@orderHC-1)*(j-1)+floor((i-1)/d@M)+1\n        beta[t,i] <- beta[t,i]+d@A[i,col]*d@RB[j, rowC ,s@y[t+1]]*beta[t+1,col]\n      }\n    }\n    scaled <- march.dcmm.h.scaleAlpha(d@M^d@orderHC,beta[t,])\n    beta[t,] <- scaled$scaled\n    l[t] <- log(scaled$scale)\n  }\n  \n  if( d@orderHC>1 ){\n    for( t in march.h.seq(d@orderVC+d@orderHC-1,d@orderVC+1,-1)){\n      rowC <- march.dcmm.h.encodeOutput(s,t+1,d)\n      for( i in 1:d@M^(t-d@orderVC)){\n        for( j in 1:d@M ){\n          col <- d@M^(t-d@orderVC)*(j-1)+i\n          beta[t,i] <- beta[t,i]+d@Pi[t-d@orderVC+1,i,j]*d@RB[j, rowC ,s@y[t+1]]*beta[t+1,col]\n        }\n      }\n      scaled <- march.dcmm.h.scaleAlpha(d@M^(t-d@orderVC),beta[t,])\n      beta[t,] <- scaled$scaled\n      l[t] <- log(scaled$scale)\n    }\n  }\n  \n  list(beta=beta,l=l)\n}\n\n\nmarch.dcmm.epsilon <- function(d,s,alpha,beta,SAlog,SBlog,LLAlpha){\n  epsilon <- array(0,c(s@N-1,d@M^d@orderHC,d@M))\n  zepsilon <- array(1,c(s@N-1,d@M^d@orderHC,d@M))\n  \n  for( t in march.h.seq(d@orderVC+1,d@orderVC+d@orderHC-1)){\n    rowC <-  march.dcmm.h.encodeOutput(s,t+1,d)\n    for( i in 1:d@M^(t-d@orderVC)){\n      j <- 1:d@M\n      col <- d@M^(t-d@orderVC)*(j-1)+i\n      zepsilon[t,i,j] <- alpha[t,i] & beta[t+1,col] & d@Pi[t-d@orderVC+1,i,j] & d@RB[j, rowC,s@y[t+1]]\n    }\n  } \n  \n  for( t in march.h.seq(d@orderHC+d@orderVC,s@N-1)){\n    rowC <- march.dcmm.h.encodeOutput(s,t+1,d)\n    for( i in 1:d@M^d@orderHC ){\n      j<-1:d@M\n      col <- d@M^(d@orderHC-1)*(j-1)+floor((i-1)/d@M)+1\n      zepsilon[t,i,j] <- alpha[t,i] & beta[t+1,col] & d@A[i,col] & d@RB[j, rowC,s@y[t+1]]\n    }\n  }\n  \n  LSAfact <- 0\n  for( t in march.h.seq(d@orderVC+1,d@orderVC+d@orderHC-1)){\n    rowC <- march.dcmm.h.encodeOutput(s,t+1,d)\n    LSAfact = LSAfact+SAlog[t]\n    for( i in 1:d@M^(t-d@orderVC)){\n      for( j in 1:d@M ){\n        if( zepsilon[t,i,j] ){\n          epsilon[t,i,j] <- LSAfact+log(alpha[t,i])+log(d@Pi[t-d@orderVC+1,i,j])+log(d@RB[j,rowC,s@y[t+1]])\n        }\n      }\n    } \n  }\t\n  \n  for( t in march.h.seq(d@orderHC+d@orderVC,s@N-1)){\n    rowC <- march.dcmm.h.encodeOutput(s,t+1,d)\n    LSAfact = LSAfact+SAlog[t]\n    \n    for( i in 1:(d@M^d@orderHC) ){\n      for( j in 1:d@M ){\n        col <- d@M^(d@orderHC-1)*(j-1)+floor((i-1)/d@M)+1     \n        if( zepsilon[t,i,j] ){\n          epsilon[t,i,j] <- LSAfact+log(alpha[t,i])+log(d@A[i,col])+log(d@RB[j,rowC,s@y[t+1]])      \n        }    \n      }   \n    }\n  }\n  \n  LSBfact <- 0\n  for( t in march.h.seq(s@N-1,d@orderHC+d@orderVC,-1)){\n    LSBfact <- LSBfact+SBlog[t+1]\n    for( i in 1:d@M^d@orderHC ){\n      for( j in 1:d@M ){\t      \n        if( zepsilon[t,i,j] ){\t        \n          col <- d@M^(d@orderHC-1)*(j-1)+floor((i-1)/d@M)+1\n          epsilon[t,i,j] <- exp(epsilon[t,i,j] + LSBfact+log(beta[t+1,col])-LLAlpha)\n        }\n      }\n    }\n  }\n  \n  if( d@orderHC> 1){\n    for( t in march.h.seq(d@orderHC+d@orderVC-1,d@orderVC+1,-1)){\n      LSBfact <- LSBfact+SBlog[t+1]\n      for( i in 1:d@M^(t-d@orderVC) ){\n        for( j in 1:d@M ){\n          if( zepsilon[t,i,j] ){\n            col <- d@M^(t-d@orderVC)*(j-1)+i\n            epsilon[t,i,j] <- exp(epsilon[t,i,j]+LSBfact+log(beta[t+1,col])-LLAlpha)\n          }\n        }\n      }\n    }\n  }\n  \n  epsilon\n}\n\nmarch.dcmm.gamma <- function(d,s,alpha,beta,SAlog,SBlog,LL,epsilon){\n  gamma <- array(0,c(s@N,d@M^d@orderHC))\n  \n  for( t in march.h.seq(d@orderVC+1,d@orderVC+d@orderHC-1)){\n    for( i in 1:d@M^(t-d@orderVC)){\n      gamma[t,i] <- sum(epsilon[t,i,])\n    }\n  }\n  \n  for( t in march.h.seq(d@orderVC+d@orderHC,s@N-1)){\n    for( i in 1:d@M^d@orderHC){\n      gamma[t,i] <- sum(epsilon[t,i,])\n    }\n  }\n  \n  t <- s@N\n  for( i in 1:d@M^d@orderHC){\n    gamma[t,i] <- exp(log(alpha[t,i])+sum(SAlog)+SBlog[t]-LL) \n  }\n  gamma\n}\n\n#\n# Baum-Welch algorithm applied to Dcmm\n#\nmarch.dcmm.bw <- function(d,y){\n  \n  RA <- array(0,c(d@M^d@orderHC,d@M))\n  RB <- array(0,c(d@M,d@y@K^d@orderVC,d@y@K))\n  Pi <- array(0,c(d@orderHC,d@M^(d@orderHC-1),d@M))\n  \n  for( n in 1:y@N ){\t\t\n    # extract the current sequence\n    s <- march.dataset.h.extractSequence(y,n)\n    \n    # First compute all the needed data, depending on d and y\n    a <- march.dcmm.forward(d,s)\n    b <- march.dcmm.backward(d,s)\n    epsilon <- march.dcmm.epsilon(d,s,a$alpha,b$beta,a$l,b$l,a$LL)\n    gamma <- march.dcmm.gamma(d,s,a$alpha,b$beta,a$l,b$l,a$LL,epsilon)\n    \n    # Reestimation of the RA\n    #print(RA)\n    for( t in march.h.seq(d@orderVC+d@orderHC,s@N-1)){\n      RA <- RA+epsilon[t,,]\n    }\n    \n    tot <- rowSums(RA)\n    #print(d)\n    for( i in 1:d@M^d@orderHC ){\n      if( tot[i]>0 ){\n        RA[i,] <- RA[i,]/tot[i]\t\n      }\n    }\n    \n    \n    # Reestimation of RB\n    for( t in march.h.seq((d@orderVC+1),(d@orderHC+d@orderVC-1))){\n      rowC <- march.dcmm.h.encodeOutput(s,t,d)\n      for( m in 1:d@M){\n        RB[m,rowC,s@y[t]] <- RB[m,rowC,s@y[t]]+sum(gamma[t,((m-1)*d@M^(t-d@orderVC)+1):(m*d@M^(t-d@orderVC))]) \t\t\t\n      }\n    }\n    \n    for( t in (d@orderHC+d@orderVC):s@N){\n      rowC <- march.dcmm.h.encodeOutput(s,t,d)\n      for( m in 1:d@M){\n        RB[m,rowC,s@y[t]] <- RB[m,rowC,s@y[t]]+sum(gamma[t,((m-1)*d@M^(d@orderHC-1)+1):(m*d@M^(d@orderHC-1))]) \t\n      }\n    }\n    \n    for( m in 1:d@M ){\n      tot <- RB[m,,]%*%march.h.ones(d@y@K,1)\n      \n      for( j in 1:(d@y@K^d@orderVC )){\n        if( tot[j] ){\n          RB[m,j,] <- RB[m,j,]/tot[j]\n        }\n      }\n    }\n    \n    # Reestimation of PI\n    Pi[1,1,] <- Pi[1,1,]+gamma[d@orderVC+1,1:d@M]\n    \n    for( t in march.h.seq(2,d@orderHC) ){\n      for( i in 1:(d@M^(t-1))){\n        if( gamma[d@orderVC+t-1,i]>0 )\n          Pi[t,i,] <- Pi[t,i,]+epsilon[d@orderVC+t-1,i,]/gamma[d@orderVC+t-1,i]\t\t\t\t\n      }\n    }\t\n  }\n  Pi <- Pi/y@N\n  \n  # Expansion of RA into A\n  A <- march.dcmm.h.expandRA(d,RA)\n  \n  # finally return a new Dcmm with the reestimated probability distributions\n  new(\"march.Dcmm\",Pi=Pi,A=A,M=d@M,y=d@y,orderVC=d@orderVC,orderHC=d@orderHC,RB=RB)\n}\n\n#' Construct a double chain Markov model (DCMM).\n#' \n#' Construct a \\code{\\link{march.Dcmm}} object, with visible order \\emph{orderVC}, hidden order \\emph{orderHC} and \\emph{M} hidden states, according to a \\code{\\link{march.Dataset}}, \n#' truncated from the first \\emph{maxOrder}-\\emph{orderVC} element of each sequence in order to return a model\n#' which can be compared with other Markovian model of visible order maxOrder. The construction is performed either by an evolutionary algorithm or by improving an existing DCMM.\n#' The EA performs \\emph{gen} generations on a population of \\emph{popSize} individuals. The EA behaves as a Lamarckian evolutionary algorithm, using a Baum-Welch algorithm as \n#' optimization step, running until log-likelihood improvment is less than \\emph{stopBw} or for \\emph{iterBw} iterations. Finally only the best individual from the population is returned as solution.\n#' If a seedModel is provided, the only step executed is the optimization step, parameters related to the EA does not apply in this case.\n#' \n#' @param y the dataset from which the Dcmm will be constructed \\code{\\link{march.Dataset}}.\n#' @param orderHC the order of the hidden chain of the constructed Dcmm.\n#' @param orderVC the order of the visible chain of the constructed Dcmm (0 result in a HMM).\n#' @param M the number of hidden state of the Dcmm.\n#' @param gen the number of generation performed by the EA.\n#' @param popSize the number of individual stored into the population.\n#' @param maxOrder the maximum visible order among the set of Markovian models to compare.\n#' @param seedModel a model to optimize using Baum-Welch algorithm.\n#' @param iterBw the number of iteration performed by the Baum-Welch algorithm.\n#' @param stopBw the minimum increase in quality (log-likelihood) authorized in the Baum-Welch algorithm.\n#' \n#' @return the best \\code{\\link{march.Dcmm}} constructed by the EA or the result of the Baum-Welch algorithm on \\emph{seedModel}.\n#' \n#' @author Ogier Maitre\n#' @example examples/march.dcmm.construct.example.R\n#' @seealso \\code{\\link{march.Dcmm}}, \\code{\\link{march.Model}}, \\code{\\link{march.Dataset}}.\n#' \n#' @export\nmarch.dcmm.construct <- function(y,orderHC,orderVC,M,gen=5L,popSize=4L,maxOrder=orderVC,seedModel=NULL,iterBw=2L,stopBw=0.1){\n  \n  orderHC <- march.h.paramAsInteger(orderHC)\n  orderVC <- march.h.paramAsInteger(orderVC)\n  M <- march.h.paramAsInteger(M)\n  maxOrder <- march.h.paramAsInteger(maxOrder)\n  iterBw <- march.h.paramAsInteger(iterBw)\n  \n  if( orderVC>maxOrder ){\n    stop(\"maxOrder should be greater or equal than orderVC\")\n  }\n  \n  gen <- march.h.paramAsInteger(gen)\n  popSize <- march.h.paramAsInteger(popSize)\n  \n  #\n  y <- march.dataset.h.filtrateShortSeq(y,maxOrder+1)\n  y <- march.dataset.h.cut(y,maxOrder-orderVC)\n  \n  if( is.null(seedModel)==FALSE ){\n    op <- new(\"march.dcmm.ea.OptimizingParameters\",fct=march.dcmm.ea.optimizing,ds=y,stopBw=stopBw,iterBw=iterBw)\n    m <- march.dcmm.ea.optimizing(seedModel,op)   \n    \n    m@dsL <- sum(y@T)\n    m@y <- y\n    #m@ll <- march.dcmm.forward(m,march.dataset.h.extractSequence(y,1))$LL\n    m@ll <- march.dcmm.h.computeLL(m,y)\n    m\n  }\n  else{\n    ep <- new(\"march.dcmm.ea.EvalParameters\",ds=y,fct=march.dcmm.ea.evaluation)\n    ip <- new(\"march.dcmm.ea.InitParameters\",AConst=FALSE,y=y,orderVC=orderVC,orderHC=orderHC,M=M,fct=march.dcmm.ea.initialization)\n    mp <- new(\"march.dcmm.ea.MutationParameters\",pMut=as.numeric(0.05),fct=march.dcmm.ea.mutation)\n    cp <- new(\"march.ea.CrossoverParameters\",fct=march.dcmm.ea.crossover)\n    \n    op <- new(\"march.dcmm.ea.OptimizingParameters\",fct=march.dcmm.ea.optimizing,ds=y,stopBw=stopBw,iterBw=iterBw)\n    p <- new(\"march.ea.Parameters\",optimizing=TRUE,\n             initParameters=ip,evalParameters=ep,mutationParameters = mp, optimizingParameters=op,crossoverParameters=cp,\n             populationSize=popSize,crossoverProb=0.5,generation=gen)\n    res<-march.loop(p)\n    \n    res$best@dsL <- sum(y@T)\n    res$best@y <- y\n    res$best@ll <-march.dcmm.h.computeLL(res$best,y)\n    res$best\n  }\n}\n",
    "created" : 1392903713647.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3260678715",
    "id" : "D6B9BB7F",
    "lastKnownWriteTime" : 1400742915,
    "path" : "~/Desktop/Bur/mc-RC3/mc/R/march.dcmm.R",
    "project_path" : "R/march.dcmm.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}