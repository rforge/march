install.packages("march", repos="http://R-Forge.R-project.org")
View(march.mtd.construct())
library(march)
View(march.mtd.construct())
View(march.mtd.construct)
setwd("march")
setwd("pkg")
load_all()
library(devtools)
load_all()
# Compute a first-order homogeneous Markov Chain for the pewee data.
MC1 <- march.mc.construct(pewee,1)
# Display the transition matrix
print(MC1@RC)
# Compute the half-length 95% confidence interval for each row of the transition matrix.
march.thompson(MC1,alpha=0.05)
# Compute a third-order MTD model for the pewee data.
MTD3 <- march.mtd.construct(pewee,3)
# Display the model
print(MTD3)
# Compute the half-length 95% confidence interval for the vector of lags
# and for each row of the transition matrix.
march.thompson(MTD3,alpha=0.05)
pewee
load("C:/Users/Kevin/Documents/march/pkg/data/pewee.rda")
MC1 <- march.mc.construct(pewee,1)
MC1
pewee
# Create a march dataset from the sleep_df dataframe included in the march package.
sleep <- march.dataset.loadFromDataFrame(sleep_df, MARGIN = 2,
weights = NA, missingDataRep = NA)
# Each row of sleep_df contains the data for one subject, so MARGIN was set to 2.
# Most of the subjects have been observed during 7 consecutive years,
# but some subjects have been observed for only 5 or 6 years.
# To load only the first 5 observations of each subject:
sleep.5 <- march.dataset.loadFromDataFrame(sleep_df[,1:5], MARGIN = 2 ,
weights = NA, missingDataRep = NA)
# The sleep data are not weighted.
# To add a weighting variable taking value 1.5 for the 500 first subjects
# and value 0.5 for the 500 next:
weighting <- rep(1.5,1000)
weighting[501:1000] <- rep(0.5,500)
sleep.w <- march.dataset.loadFromDataFrame(sleep_df, MARGIN = 2,
weights = weighting, missingDataRep = NA)
save(sleep,file="sleep.rda")
pewee <- march.dataset.loadFromDataFrame(sleep_df, MARGIN = 1,
weights = NA, missingDataRep = NA)
pewee
save(pewee,file="pewee.rda")
# Compute a first-order homogeneous Markov Chain for the pewee data.
MC1 <- march.mc.construct(pewee,1)
# Display the transition matrix
print(MC1@RC)
# Compute the half-length 95% confidence interval for each row of the transition matrix.
march.thompson(MC1,alpha=0.05)
# Compute a third-order MTD model for the pewee data.
MTD3 <- march.mtd.construct(pewee,3)
# Display the model
print(MTD3)
# Compute the half-length 95% confidence interval for the vector of lags
# and for each row of the transition matrix.
march.thompson(MTD3,alpha=0.05)
# Compute a third-order homogeneous Markov Chain for the pewee data.
model <- march.mc.construct(pewee,3)
# Assign its name to the model.
march.name(model)
# Build a 4th order MTD model from the pewee data set.
model <- march.mtd.construct(pewee,4)
print(model)
# Build a 3th order MTDg model from the pewee data set.
model <- march.mtd.construct(pewee,3,mtdg=TRUE)
print(model)
# pewee dataset is a data object of the march package in march.Dataset class format.
model <- march.mc.construct(pewee,2)
# print the reduced form of the transition matrix of the Markovian Model.
print(model@RC)
# Build an independance model from the pewee data set.
model <- march.indep.construct(pewee)
print(model)
# Estimation of a DCMM
set.seed(327)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(327)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(327)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
#bestSeq <- march.dcmm.viterbi(model,pewee)
#print(bestSeq)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden order set to 2 and visible order set to 1.
# The estimation procedure uses both the evolutionary algorithm (population size 2,
# one iteration) and the Bauw-Welch algorithm (one iteration).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
\dontrun{
# Same as above, but the DCMM is replaced by a HMM (the visible order OrderVC is set to zero).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=0,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[2]],
orderVC=3,iterBw=10,stopBw=0.0001)
# Show performance indicators (ll, number of independent parameters,
# BIC and AIC) for all computed models.
r <- do.call(rbind,lapply(models,march.summary))
print(r)
# Construct a three hidden states, first-order HMM (hence OrderVC=0) for the sleep data.
# By setting gen=1 and popSize=1, the estimation procedure uses only the Baum-Welch algorithm.
HMM <- march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
print(HMM)
# Compute the best sequence of hidden states for each subject in the sleep data.
HS <- march.dcmm.viterbi(HMM,sleep)
# Display the hidden states for the first 10 subjects.
print(HS[1:10])
}
# Create a march dataset from the sleep_df dataframe included in the march package.
sleep <- march.dataset.loadFromDataFrame(sleep_df, MARGIN = 2,
weights = NA, missingDataRep = NA)
# Each row of sleep_df contains the data for one subject, so MARGIN was set to 2.
# Most of the subjects have been observed during 7 consecutive years,
# but some subjects have been observed for only 5 or 6 years.
# To load only the first 5 observations of each subject:
sleep.5 <- march.dataset.loadFromDataFrame(sleep_df[,1:5], MARGIN = 2 ,
weights = NA, missingDataRep = NA)
# The sleep data are not weighted.
# To add a weighting variable taking value 1.5 for the 500 first subjects
# and value 0.5 for the 500 next:
weighting <- rep(1.5,1000)
weighting[501:1000] <- rep(0.5,500)
sleep.w <- march.dataset.loadFromDataFrame(sleep_df, MARGIN = 2,
weights = weighting, missingDataRep = NA)
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
pewee
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
y=pewee
seedModel=NULL
popSize=4
gen=5
orderHC=2
orderVC=1
M=2
popSize=2
gen=1
iterBw=1
stopBw=0.0001
if( is.null(seedModel) ){
orderHC <- march.h.paramAsInteger(orderHC)
orderVC <- march.h.paramAsInteger(orderVC)
M <- march.h.paramAsInteger(M)
maxOrder <- march.h.paramAsInteger(maxOrder)
if( orderVC>maxOrder ){
stop("maxOrder should be greater or equal than orderVC")
}
}
maxOrder=orderVC
if( is.null(seedModel) ){
orderHC <- march.h.paramAsInteger(orderHC)
orderVC <- march.h.paramAsInteger(orderVC)
M <- march.h.paramAsInteger(M)
maxOrder <- march.h.paramAsInteger(maxOrder)
if( orderVC>maxOrder ){
stop("maxOrder should be greater or equal than orderVC")
}
}
iterBw <- march.h.paramAsInteger(iterBw)
gen <- march.h.paramAsInteger(gen)
popSize <- march.h.paramAsInteger(popSize)
if( is.null(seedModel) ){
y <- march.dataset.h.filtrateShortSeq(y,maxOrder+1)
y <- march.dataset.h.cut(y,maxOrder-orderVC)
}
if( is.null(seedModel)==FALSE ){
# AB
y <- march.dataset.h.filtrateShortSeq(y,maxOrder+1)
y <- march.dataset.h.cut(y,maxOrder-orderVC)
# \AB
op <- new("march.dcmm.ea.OptimizingParameters",fct=march.dcmm.ea.optimizing,ds=y,stopBw=stopBw,iterBw=iterBw)
m <- march.dcmm.ea.optimizing(seedModel,op)
# AB
m@dsL <- sum(y@T-orderVC)
#m@dsL <- sum(y@T)
# \AB
m@y <- y
#m@ll <- march.dcmm.forward(m,march.dataset.h.extractSequence(y,1))$LL
m@ll <- march.dcmm.h.computeLL(m,y)
m
}
ep <- new("march.dcmm.ea.EvalParameters",ds=y,fct=march.dcmm.ea.evaluation)
ip <- new("march.dcmm.ea.InitParameters",AConst=FALSE,y=y,orderVC=orderVC,orderHC=orderHC,M=M,fct=march.dcmm.ea.initialization)
mp <- new("march.dcmm.ea.MutationParameters",pMut=as.numeric(0.05),fct=march.dcmm.ea.mutation)
cp <- new("march.ea.CrossoverParameters",fct=march.dcmm.ea.crossover)
op <- new("march.dcmm.ea.OptimizingParameters",fct=march.dcmm.ea.optimizing,ds=y,stopBw=stopBw,iterBw=iterBw)
p <- new("march.ea.Parameters",optimizing=TRUE,
initParameters=ip,evalParameters=ep,mutationParameters = mp, optimizingParameters=op,crossoverParameters=cp,
populationSize=popSize,crossoverProb=0.5,generation=gen)
res<-march.loop(p)
p
population <- list()
fitness <- array(0,p@populationSize)
for( i in 1:p@populationSize ){
population[[i]] <- p@initParameters@fct(p@initParameters)
fitness[i] <- p@evalParameters@fct(population[[i]],p@evalParameters)
}
fitnessProb <- fitness/sum(fitness)
prop <- cumsum(fitnessProb)-fitnessProb[1]
childrenPopulation <- list()
childrenFitness <- array(0,p@populationSize)
for( i in seq(1,p@populationSize,2) ){
sel1 <- max(which(prop<runif(1)))
sel2 <- max(which(prop<runif(1)))
# Do we need to crossover
if( runif(1)<p@crossoverProb ){
children <- p@crossoverParameters@fct(population[[sel1]],population[[sel2]])
child1 <- children$c1
child2 <- children$c2
}
else{
child1 <- population[[sel1]]
child2 <- population[[sel2]]
}
child1 <- p@mutationParameters@fct(child1,p@mutationParameters)
child2 <- p@mutationParameters@fct(child2,p@mutationParameters)
if( p@optimizing ){
child1 <- p@optimizingParameters@fct(child1,p@optimizingParameters)
child2 <- p@optimizingParameters@fct(child2,p@optimizingParameters)
}
# eval the generated individual
childrenFitness[i] <- p@evalParameters@fct(child1,p@evalParameters)
childrenFitness[i+1] <- p@evalParameters@fct(child2,p@evalParameters)
childrenPopulation[[i]] <- child1
childrenPopulation[[i+1]] <- child2
}
population <- list()
fitness <- array(0,p@populationSize)
for( i in 1:p@populationSize ){
population[[i]] <- p@initParameters@fct(p@initParameters)
fitness[i] <- p@evalParameters@fct(population[[i]],p@evalParameters)
}
p@generation
fitnessProb <- fitness/sum(fitness)
prop <- cumsum(fitnessProb)-fitnessProb[1]
childrenPopulation <- list()
childrenFitness <- array(0,p@populationSize)
sel1 <- max(which(prop<runif(1)))
sel2 <- max(which(prop<runif(1)))
if( runif(1)<p@crossoverProb ){
children <- p@crossoverParameters@fct(population[[sel1]],population[[sel2]])
child1 <- children$c1
child2 <- children$c2
}
else{
child1 <- population[[sel1]]
child2 <- population[[sel2]]
}
# Do we need to crossover
if( runif(1)<p@crossoverProb ){
children <- p@crossoverParameters@fct(population[[sel1]],population[[sel2]])
child1 <- children$c1
child2 <- children$c2
}
else{
child1 <- population[[sel1]]
child2 <- population[[sel2]]
}
if( runif(1)<p@crossoverProb ){
children <- p@crossoverParameters@fct(population[[sel1]],population[[sel2]])
child1 <- children$c1
child2 <- children$c2
}else{
child1 <- population[[sel1]]
child2 <- population[[sel2]]
}
child1 <- p@mutationParameters@fct(child1,p@mutationParameters)
child2 <- p@mutationParameters@fct(child2,p@mutationParameters)
p@optimizing
child1 <- p@optimizingParameters@fct(child1,p@optimizingParameters)
child1
d=child1
p=p@optimizingParameters
for( i in 1:d@M^d@orderHC ){
if( sum(d@A[i,])!=0 ){
d@A[i,] <- d@A[i,]/sum(d@A[i,])
}
}
for( i in d@M ){
for( j in d@y@K^d@orderVC ){
if( sum(d@RB[i,j,])!=0 )
d@RB[i,j,] <- d@RB[i,j,]/sum(d@RB[i,j,])
}
}
for( i in 1:d@orderHC ){
for( j in 1:(d@M^(i-1))){
if( sum(d@Pi[i,j,])!=0 ){
d@Pi[i,j,] <- d@Pi[i,j,]/sum(d@Pi[i,j,])
}
}
}
opt <- d  # the optimized individual.
referenceLL <- march.dcmm.h.computeLL(opt,p@ds)
march.h.seq(1,p@iterBw)
Tempmod <- march.dcmm.bw(opt,p@ds)
opt
p@ds
pewee
load("C:/Users/Kevin/Documents/march/pkg/data/pewee.rda")
pewee<-march.dataset.loadFromDataFrame(pewee_df)
pewee
pewee<-march.dataset.loadFromDataFrame(pewee_df,MARGIN=1)
pewee
save(pewee,file="pewee.rda")
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden order set to 2 and visible order set to 1.
# The estimation procedure uses both the evolutionary algorithm (population size 2,
# one iteration) and the Bauw-Welch algorithm (one iteration).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
\dontrun{
# Same as above, but the DCMM is replaced by a HMM (the visible order OrderVC is set to zero).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=0,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[2]],
orderVC=3,iterBw=10,stopBw=0.0001)
# Show performance indicators (ll, number of independent parameters,
# BIC and AIC) for all computed models.
r <- do.call(rbind,lapply(models,march.summary))
print(r)
# Construct a three hidden states, first-order HMM (hence OrderVC=0) for the sleep data.
# By setting gen=1 and popSize=1, the estimation procedure uses only the Baum-Welch algorithm.
HMM <- march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden order set to 2 and visible order set to 1.
# The estimation procedure uses both the evolutionary algorithm (population size 2,
# one iteration) and the Bauw-Welch algorithm (one iteration).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
# Same as above, but the DCMM is replaced by a HMM (the visible order OrderVC is set to zero).
march.dcmm.construct(y=pewee,orderHC=2,orderVC=0,M=2,popSize=2,gen=1,iterBw=1,stopBw=0.0001)
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[2]],
orderVC=3,iterBw=10,stopBw=0.0001)
# Show performance indicators (ll, number of independent parameters,
# BIC and AIC) for all computed models.
r <- do.call(rbind,lapply(models,march.summary))
print(r)
# Construct a three hidden states, first-order HMM (hence OrderVC=0) for the sleep data.
# By setting gen=1 and popSize=1, the estimation procedure uses only the Baum-Welch algorithm.
HMM <- march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
print(HMM)
# Compute the best sequence of hidden states for each subject in the sleep data.
HS <- march.dcmm.viterbi(HMM,sleep)
# Display the hidden states for the first 10 subjects.
print(HS[1:10])
# Estimation of a DCMM
set.seed(327)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
indepModel <- march.indep.construct(pewee)
march.BIC(indepModel)
indepModel <- march.indep.construct(pewee)
march.AIC(indepModel)
devtools::document()
devtools::document()
# Compute a first-order homogeneous Markov Chain for the pewee data.
MC1 <- march.mc.construct(pewee,1)
# Display the transition matrix
print(MC1@RC)
# Compute the half-length 95% confidence interval for each row of the transition matrix.
march.thompson(MC1,alpha=0.05)
# Compute a third-order MTD model for the pewee data.
MTD3 <- march.mtd.construct(pewee,3)
# Display the model
print(MTD3)
# Compute the half-length 95% confidence interval for the vector of lags
# and for each row of the transition matrix.
march.thompson(MTD3,alpha=0.05)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
