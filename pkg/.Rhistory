model <- march.dcmm.construct(sleep,orderHC=1,orderVC=4,M=2,popSize=2,gen=1)
model <- march.dcmm.construct(sleep,orderHC=2,orderVC=3,M=2,popSize=2,gen=1)
data(pewee_df)
p2 <- pewee_df
View(p2)
p2$V2 <- p2
View(p2)
p2$V2 <- p2$V1
View(p2)
PEWEE < march.dataset.loadFromDataFrame(p2, MARGIN = 2, weights = NA,
missingDataRep = NA)
PEWEE <- march.dataset.loadFromDataFrame(p2, MARGIN = 2, weights = NA,
missingDataRep = NA)
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
PEWEE@T
PEWEE <- march.dataset.loadFromDataFrame(p2, MARGIN = 1, weights = NA,
missingDataRep = NA)
PEWEE@T
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
models <- march.dcmm.construct(sleep,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
PEWEE@T
PEWEE@T[2] <- 5
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
PEWEE@Y
PEWEE@y
PEWEE@y[2,6] <- NA
PEWEE@y[6,2] <- NA
View(PEWEE@y)
p2
p3 <- pewee_df
p3
p3[6,1] <- NA
p2$V2 <- p3
p2
View(p2)
p2$V2 <- p3$V1
View(p2)
PEWEE <- march.dataset.loadFromDataFrame(p2, MARGIN = 1, weights = NA,
missingDataRep = NA)
PEWEE@T
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
summary(sleep)
summary(sleep_df)
model2 <- march.dcmm.construct(sleep,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
p3[5,1] <- NA
p2$V2 <- p3$V1
PEWEE <- march.dataset.loadFromDataFrame(p2, MARGIN = 1, weights = NA,
missingDataRep = NA)
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
library(march)
model <- march.dcmm.construct(PEWEE,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
print(model)
model2 <- march.dcmm.construct(sleep,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
model2 <- march.dcmm.construct(sleep,orderHC=2,orderVC=3,M=2,popSize=1,gen=1)
model2 <- march.dcmm.construct(sleep,orderHC=3,orderVC=3,M=2,popSize=1,gen=1)
model2 <- march.dcmm.construct(sleep,orderHC=2,orderVC=4,M=2,popSize=1,gen=1)
model2 <- march.dcmm.construct(sleep,orderHC=1,orderVC=3,M=2,popSize=1,gen=1)
print(model2)
summary(sleep_df)
mc3 <- march.mc.construct(sleep,order=3)
print(mc3)
mc4 <- march.mc.construct(sleep,order=4)
print(mc4)
library(march)
library(march)
library(march)
library(march)
library(march)
library(march)
mc2 <- march.mc
mc2 <- march.mc.construct(pewee,order=2)
library(march)
mc2 <- march.mc.construct(pewee,order=2)
library(march)
mc2 <- march.mc.construct(pewee,order=2)
library(march)
mc2 <- march.mc.construct(pewee,order=2)
library(march)
mc2 <- march.mc.construct(pewee,order=2)
library(march)
mc2 <- march.mc.construct(pewee,order=2)
march.mc.construct(pewee,order=2)
march.mc.construct(pewee,order=1)
march.mc.construct(pewee,order=2)
library(march)
march.mc.construct(pewee,order=2)
?march.thompson
library(march)
?march.thompson
?march.thompson.Dcmm
march.name-class
?march.Dcmm-method
?`march.Dcmm-class`
?`march.Dcmm-method`
??`march.Dcmm-method`
?march.name
?march.Dcmm-method.Rd
?march.Dcmm-method
?march.Dcmm
??march.Dcmm
library("march", lib.loc="~/R/win-library/3.2")
7
search()
?importfrom
?@ImportFrom
?ImportFrom
??ImportFrom
library(march)
# Estimation of a DCMM
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
help(time)
# Estimation of a DCMM
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=2,M=3,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=2,M=3,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=2,M=3,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=3,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=2)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(1234)
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(4321)
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(111)
#model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=3,M=4,popSize=2,gen=2)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Build a 4th order MTD model from the pewee data set.
model <- march.mtd.construct(pewee,4)
print(model)
# Build a 3th order MTDg model from the pewee data set.
model <- march.mtd.construct(pewee,3,mtdg=TRUE)
print(model)
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[2]],
orderVC=3,iterBw=10,stopBw=0.0001)
# Show performance indicators (ll, number of independent parameters,
# BIC and AIC) for all computed models.
r <- do.call(rbind,lapply(models,march.summary))
print(r)
# Construct a three hidden states, first-order HMM (hence OrderVC=0) for the sleep data.
# By setting gen=1 and popSize=1, the estimation procedure uses only the Baum-Welch algorithm.
HMM <- march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
print(HMM)
# Compute the best sequence of hidden states for each subject in the sleep data.
HS <- march.dcmm.viterbi(HMM,sleep)
# Display the hidden states for the first 10 subjects.
print(HS[1:10])
help(skip)
help(skip_on_cran)
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=5,stopBw=0.001)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=5,stopBw=0.001)
skip_on_cran(
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[2]],
orderVC=3,iterBw=10,stopBw=0.0001)
# Show performance indicators (ll, number of independent parameters,
# BIC and AIC) for all computed models.
r <- do.call(rbind,lapply(models,march.summary))
print(r)
# Construct a three hidden states, first-order HMM (hence OrderVC=0) for the sleep data.
# By setting gen=1 and popSize=1, the estimation procedure uses only the Baum-Welch algorithm.
HMM <- march.dcmm.construct(sleep,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=10,stopBw=0.0001)
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,seedModel=models[[1]],
orderVC=3,iterBw=10,stopBw=0.001)
library(TraMineR)
help("TraMineR")
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=5,stopBw=0.001)
## Not run:
# Construct a DCMM using an order 2 hidden chain,
# a visible chain of order 3 and 3 hidden states.
# A first model is computed using both EA and Baum-Welch algorithms.
# Then the initial solution is improved through two rounds of Baum-Welch optimization.
models <- list()
models[[length(models)+1]] <- march.dcmm.construct(y=pewee,orderHC=2,
orderVC=3,M=3,popSize=2,gen=2)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=3,stopBw=0.001)
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=3,stopBw=0.001)
help(march)
library(march)
library(march)
help(march)
library(march)
library(roxygen2)
install.packages("roxygen")
install.packages("roxygen2")
library(march)
help("march")
library(march)
help("march")
library(march)
help("march")
library(march)
library(march)
help("march")
help(march)
library(march)
help(march)
dir()
library(march)
help(march)
# Estimation of a DCMM
set.seed(111)
# Computation of a very simple DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=1,gen=1)
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
start.time <- Sys.time(), model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1), end.time <- Sys.time(), end.time - start.time
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=2,gen=1)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=2,orderVC=1,M=2,popSize=1,gen=1)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
end.time <- Sys.time()
end.time - start.time
# Estimation of a DCMM
set.seed(111)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(222)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(333)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(123)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(1234)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(321)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(322)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(323)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(324)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(325)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
# Estimation of a DCMM
set.seed(327)
# Computation of a the simplest DCMM model
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
# Extraction of the best sequence of hidden states using the Viterbi algorithm.
bestSeq <- march.dcmm.viterbi(model,pewee)
print(bestSeq)
library(TraMineR)
help("TraMineR")
start.time <- Sys.time()
model <- march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=1,gen=1)
end.time <- Sys.time()
end.time - start.time
mvad.seq <- seqdef(mvad[, 17:86])
data(mvad)
mvad.seq <- seqdef(mvad[, 17:86])
mvad.ham <- seqdist(mvad.seq, method="HAM")
dt <- disstree(mvad.ham~ male + Grammar + funemp + gcse5eq + fmpr + livboth,
data=mvad, R = 10)
print(dt)
disstreedisplay(dt, imagefunc=seqdplot, imagedata=mvad.seq,
## Additional parameters passed to seqdplot
withlegend=FALSE, axes=FALSE, ylab="")
## Not run:
disstreedisplay(dt, imagefunc=seqdplot, imagedata=mvad.seq,
## Additional parameters passed to seqdplot
withlegend=FALSE, axes=FALSE, ylab="")
## End(Not run)
library(march)
help("march")
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=3,stopBw=0.001)
end.time <- Sys.time()
end.time - start.time
march.dcmm.construct(pewee[1:100],orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
march.dcmm.construct(y=pewee[1:100],orderHC=1,orderVC=1,M=2,popSize=2,gen=2)
pewee
pewee[1:100]
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=3,stopBw=0.001)
end.time <- Sys.time()
end.time - start.time
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=2,stopBw=0.001)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm.
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=2,stopBw=0.001)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm (one iteration only).
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=1,stopBw=0.001)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm (one iteration only).
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=1,stopBw=0.01)
end.time <- Sys.time()
end.time - start.time
start.time <- Sys.time()
# Construct a 2 hidden states DCMM for the pewee data
# with hidden and visible orders set to 1.
# The estimation procedure uses only the evolutionary algorithm.
march.dcmm.construct(y=pewee,orderHC=1,orderVC=1,M=2,popSize=2,gen=1)
# Construct a first-order, three hidden states HMM for the pewee data.
# The estimation procedure uses only the Bauw-Welch algorithm (one iteration only).
march.dcmm.construct(pewee,orderHC=1,orderVC=0,M=3,gen=1,popSize=1,iterBw=1,stopBw=0.0001)
end.time <- Sys.time()
end.time - start.time
library(march)
library(march)
